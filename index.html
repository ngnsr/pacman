<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pac-Man Game with AI Ghosts</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        background-color: #000;
        font-family: Arial, sans-serif;
        color: white;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      canvas {
        border: 2px solid #333;
        background-color: #000;
      }
      .controls {
        margin-top: 10px;
        text-align: center;
      }
      .info {
        margin-top: 15px;
        font-size: 14px;
        max-width: 800px;
        background-color: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #333;
      }
      .debug {
        margin-top: 10px;
        font-size: 12px;
        color: #888;
        max-width: 800px;
        background-color: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #333;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div class="controls">
      <div>
        Use WASD or Arrow Keys to move | ESC to pause | +/- to change difficulty
        | R to restart
      </div>
    </div>
    <div class="info" id="gameInfo"></div>
    <div class="debug" id="debugInfo"></div>

    <script>
      // Constants
      const SCREEN_WIDTH = 800;
      const SCREEN_HEIGHT = 600;
      const CELL_SIZE = 25;
      const FPS = 60;

      // Colors
      const BLACK = "#000000";
      const WHITE = "#FFFFFF";
      const YELLOW = "#FFFF00";
      const BLUE = "#0000FF";
      const RED = "#FF0000";
      const GREEN = "#00FF00";
      const PURPLE = "#800080";
      const ORANGE = "#FFA500";
      const PINK = "#FFC0CB";
      const CYAN = "#00FFFF";

      // Speeds
      const PACMAN_SPEED = 4.0;
      const GHOST_SPEED = 3.7;

      // Game States
      const GAME_PLAYING = "playing";
      const GAME_PAUSED = "paused";
      const GAME_WON = "won";
      const GAME_LOST = "lost";

      // Directions
      const UP = { x: 0, y: -1 };
      const DOWN = { x: 0, y: 1 };
      const LEFT = { x: -1, y: 0 };
      const RIGHT = { x: 1, y: 0 };
      const DIRECTIONS = [UP, DOWN, LEFT, RIGHT];

      const AI_DECISION_DELAY = 0.05;

      // Default map
      const DEFAULT_MAP = [
        "########################",
        "#..........##..........#",
        "#.##.#####.##.#####.##.#",
        "#......................#",
        "#.##.#.#######.#.##.#",
        "#....#....##....#....#",
        "####.####.##.####.####",
        "   #.#..........#.#   ",
        "####.#.##  ##.#.####",
        "#......##  ##......#",
        "####.#.########.#.####",
        "   #.#....P.....#.#   ",
        "####.####.##.####.####",
        "#....#....##....#....#",
        "#.##.#.#######.#.##.#",
        "#..G........G......G..#",
        "#.##.#####.##.#####.##.#",
        "#..........##..........#",
        "########################",
      ];

      // Global ghost network for communication
      class GhostNetwork {
        constructor() {
          this.sharedMemory = {};
          this.communicationRange = 4;
        }

        sharePacmanSighting(ghostPos, pacmanPos, timestamp, confidence = 1.0) {
          this.sharedMemory = {
            pacmanPos,
            timestamp,
            confidence,
            reporterPos: ghostPos,
          };
        }

        getSharedPacmanInfo(ghostPos, currentTime) {
          if (!this.sharedMemory.timestamp) return [null, 0];

          const age = currentTime - this.sharedMemory.timestamp;
          if (age > 3000) return [null, 0]; // 3 seconds

          const reporterPos = this.sharedMemory.reporterPos || { x: 0, y: 0 };
          const distance = Math.sqrt(
            Math.pow(ghostPos.x - reporterPos.x, 2) +
              Math.pow(ghostPos.y - reporterPos.y, 2)
          );

          if (distance > this.communicationRange) return [null, 0];

          const confidence =
            this.sharedMemory.confidence *
            (1 - age / 3000) *
            (1 - distance / this.communicationRange);

          return [this.sharedMemory.pacmanPos, Math.max(0, confidence)];
        }
      }

      const ghostNetwork = new GhostNetwork();

      // BFS pathfinding
      function bfsNextStep(
        startPos,
        targetPos,
        walls,
        mapWidth,
        mapHeight,
        avoidPositions = new Set()
      ) {
        if (startPos.x === targetPos.x && startPos.y === targetPos.y)
          return null;

        const queue = [{ pos: startPos, path: [] }];
        const visited = new Set();
        visited.add(`${startPos.x},${startPos.y}`);

        while (queue.length > 0) {
          const { pos, path } = queue.shift();

          for (const direction of DIRECTIONS) {
            const nextX = (pos.x + direction.x + mapWidth) % mapWidth;
            const nextY = (pos.y + direction.y + mapHeight) % mapHeight;
            const nextPos = { x: nextX, y: nextY };
            const posKey = `${nextX},${nextY}`;

            if (
              visited.has(posKey) ||
              walls.has(posKey) ||
              avoidPositions.has(posKey)
            )
              continue;

            const newPath = [...path, direction];

            if (nextX === targetPos.x && nextY === targetPos.y) {
              return newPath[0] || null;
            }

            queue.push({ pos: nextPos, path: newPath });
            visited.add(posKey);

            if (newPath.length > 15) break;
          }
        }

        return null;
      }

      // Ghost AI Rules
      class GhostRule {
        constructor(priority = 1.0, enabled = true) {
          this.priority = priority;
          this.enabled = enabled;
        }

        evaluate(ghostAI, walls, pacman, otherGhosts) {
          return [null, 0.0];
        }
      }

      class EnhancedVisionRule extends GhostRule {
        constructor(
          sightRadius = 5,
          soundRadius = 2,
          memoryDuration = 2000,
          priority = 3.0
        ) {
          super(priority);
          this.sightRadius = sightRadius;
          this.soundRadius = soundRadius;
          this.memoryDuration = memoryDuration;
          this.lastKnownPacmanPos = null;
          this.lastSeenTime = 0;
        }

        detectPacman(ghostAI, pacman, walls, currentTime) {
          const ghostPos = { x: ghostAI.ghost.gridX, y: ghostAI.ghost.gridY };
          let pacmanPos = { x: pacman.gridX, y: pacman.gridY };
          const distance = Math.sqrt(
            Math.pow(ghostPos.x - pacmanPos.x, 2) +
              Math.pow(ghostPos.y - pacmanPos.y, 2)
          );

          let detected = false;
          let detectionConfidence = 0.0;
          let detectionMethod = "none";

          // Direct sight
          if (
            distance <= this.sightRadius &&
            this.hasLineOfSight(ghostPos, pacmanPos, walls)
          ) {
            detected = true;
            detectionConfidence = Math.min(
              1.0,
              this.sightRadius / (distance + 0.1)
            );
            detectionMethod = "sight";
          }
          // Sound detection
          else if (
            distance <= this.soundRadius &&
            (pacman.direction.x !== 0 || pacman.direction.y !== 0)
          ) {
            detected = true;
            detectionConfidence = 0.6 * (this.soundRadius / (distance + 0.1));
            detectionMethod = "sound";
          }
          // Network information
          else {
            const [sharedPos, sharedConfidence] =
              ghostNetwork.getSharedPacmanInfo(ghostPos, currentTime);
            if (sharedPos && sharedConfidence > 0.2) {
              pacmanPos = sharedPos;
              detectionConfidence = sharedConfidence * 0.85;
              detected = true;
              detectionMethod = "network";
            }
          }

          // Memory
          if (!detected && this.lastKnownPacmanPos) {
            const memoryAge = currentTime - this.lastSeenTime;
            if (memoryAge < this.memoryDuration) {
              pacmanPos = this.lastKnownPacmanPos;
              detectionConfidence = 0.3 * (1 - memoryAge / this.memoryDuration);
              detected = true;
              detectionMethod = "memory";
            }
          }

          // Update memory and network
          if (detectionMethod === "sight" || detectionMethod === "sound") {
            this.lastKnownPacmanPos = pacmanPos;
            this.lastSeenTime = currentTime;
            ghostNetwork.sharePacmanSighting(
              ghostPos,
              pacmanPos,
              currentTime,
              detectionConfidence
            );
          }

          return [detected, pacmanPos, detectionConfidence, detectionMethod];
        }

        hasLineOfSight(ghostPos, pacmanPos, walls) {
          if (ghostPos.x === pacmanPos.x && ghostPos.y === pacmanPos.y)
            return true;

          const dx = Math.abs(pacmanPos.x - ghostPos.x);
          const dy = Math.abs(pacmanPos.y - ghostPos.y);
          const sx = ghostPos.x < pacmanPos.x ? 1 : -1;
          const sy = ghostPos.y < pacmanPos.y ? 1 : -1;
          let err = dx - dy;

          let x = ghostPos.x;
          let y = ghostPos.y;

          while (true) {
            const posKey = `${x},${y}`;
            if (
              posKey !== `${ghostPos.x},${ghostPos.y}` &&
              posKey !== `${pacmanPos.x},${pacmanPos.y}` &&
              walls.has(posKey)
            ) {
              return false;
            }

            if (x === pacmanPos.x && y === pacmanPos.y) break;

            const e2 = 2 * err;
            if (e2 > -dy) {
              err -= dy;
              x += sx;
            }
            if (e2 < dx) {
              err += dx;
              y += sy;
            }
          }

          return true;
        }

        evaluate(ghostAI, walls, pacman, otherGhosts) {
          const currentTime = Date.now();
          const [detected, targetPos, confidence, method] = this.detectPacman(
            ghostAI,
            pacman,
            walls,
            currentTime
          );

          if (!detected || confidence < 0.1) return [null, 0.0];

          const ghostPos = { x: ghostAI.ghost.gridX, y: ghostAI.ghost.gridY };
          const avoidPositions = new Set();
          otherGhosts.forEach((g) => {
            if (g !== ghostAI.ghost) {
              avoidPositions.add(`${g.gridX},${g.gridY}`);
            }
          });

          const direction = bfsNextStep(
            ghostPos,
            targetPos,
            walls,
            ghostAI.game.mapWidth,
            ghostAI.game.mapHeight,
            avoidPositions
          );

          if (direction) {
            let strength = confidence * this.priority;

            if (method === "sight") strength *= 1.2;
            else if (method === "sound") strength *= 1.0;
            else if (method === "network") strength *= 0.8;
            else strength *= 0.6; // memory

            return [direction, strength];
          }

          return [null, 0.0];
        }
      }

      class IntelligentWanderRule extends GhostRule {
        constructor(priority = 0.8) {
          super(priority);
          this.positionHistory = [];
          this.directionHistory = [];
          this.explorationBonus = new Map();
        }

        evaluate(ghostAI, walls, pacman, otherGhosts) {
          const ghostPos = { x: ghostAI.ghost.gridX, y: ghostAI.ghost.gridY };
          const currentTime = Date.now();

          this.positionHistory.push(`${ghostPos.x},${ghostPos.y}`);
          if (this.positionHistory.length > 8) {
            this.positionHistory.shift();
          }

          const validDirs = [];
          for (const direction of DIRECTIONS) {
            const nextX =
              (ghostPos.x + direction.x + ghostAI.game.mapWidth) %
              ghostAI.game.mapWidth;
            const nextY =
              (ghostPos.y + direction.y + ghostAI.game.mapHeight) %
              ghostAI.game.mapHeight;
            const nextPosKey = `${nextX},${nextY}`;

            if (!walls.has(nextPosKey)) {
              let collision = false;
              for (const ghost of otherGhosts) {
                if (ghost !== ghostAI.ghost) {
                  if (
                    (ghost.gridX === nextX && ghost.gridY === nextY) ||
                    (ghost.targetX === nextX && ghost.targetY === nextY)
                  ) {
                    collision = true;
                    break;
                  }
                }
              }

              if (!collision) {
                validDirs.push({ direction, nextPos: { x: nextX, y: nextY } });
              }
            }
          }

          if (validDirs.length === 0) return [null, 0.0];

          // Score each direction
          const scoredDirs = validDirs.map(({ direction, nextPos }) => {
            let score = 0.0;
            const nextPosKey = `${nextPos.x},${nextPos.y}`;

            // Avoid recently visited places
            const recentVisits = this.positionHistory.filter(
              (pos) => pos === nextPosKey
            ).length;
            score -= recentVisits * 0.3;

            // Avoid going backwards
            if (this.directionHistory.length > 0) {
              const lastDir =
                this.directionHistory[this.directionHistory.length - 1];
              if (direction.x === -lastDir.x && direction.y === -lastDir.y) {
                score -= 0.4;
              }
            }

            // Exploration bonus
            if (!this.explorationBonus.has(nextPosKey)) {
              this.explorationBonus.set(nextPosKey, currentTime);
              score += 0.3;
            } else {
              const age = currentTime - this.explorationBonus.get(nextPosKey);
              if (age > 10000) {
                // 10 seconds
                score += 0.2;
              }
            }

            return { direction, score };
          });

          scoredDirs.sort((a, b) => b.score - a.score);

          // Choose from top choices with randomness
          const topChoices = scoredDirs.slice(0, 2);
          let chosenDirection;

          if (topChoices.length >= 2) {
            chosenDirection =
              Math.random() < 0.67
                ? topChoices[0].direction
                : topChoices[1].direction;
          } else {
            chosenDirection = topChoices[0].direction;
          }

          this.directionHistory.push(chosenDirection);
          if (this.directionHistory.length > 4) {
            this.directionHistory.shift();
          }

          return [chosenDirection, this.priority];
        }
      }

      class SmartPatrolRule extends GhostRule {
        constructor(patrolPoints = [], priority = 1.5) {
          super(priority);
          this.patrolPoints = patrolPoints;
          this.currentTarget = 0;
          this.patrolCompletionCount = 0;
          this.adaptivePriority = priority;
        }

        evaluate(ghostAI, walls, pacman, otherGhosts) {
          if (this.patrolPoints.length === 0) return [null, 0.0];

          const ghostPos = { x: ghostAI.ghost.gridX, y: ghostAI.ghost.gridY };
          let targetPos = this.patrolPoints[this.currentTarget];

          if (ghostPos.x === targetPos.x && ghostPos.y === targetPos.y) {
            this.currentTarget =
              (this.currentTarget + 1) % this.patrolPoints.length;
            if (this.currentTarget === 0) {
              this.patrolCompletionCount++;
              this.adaptivePriority = Math.max(
                0.5,
                this.priority - this.patrolCompletionCount * 0.1
              );
            }
            targetPos = this.patrolPoints[this.currentTarget];
          }

          const avoidPositions = new Set();
          otherGhosts.forEach((g) => {
            if (g !== ghostAI.ghost) {
              avoidPositions.add(`${g.gridX},${g.gridY}`);
            }
          });

          const direction = bfsNextStep(
            ghostPos,
            targetPos,
            walls,
            ghostAI.game.mapWidth,
            ghostAI.game.mapHeight,
            avoidPositions
          );

          return direction ? [direction, this.adaptivePriority] : [null, 0.0];
        }
      }

      class PredictPacmanRule extends GhostRule {
        constructor(predictionSteps = 3, priority = 2.5) {
          super(priority);
          this.predictionSteps = predictionSteps;
        }

        evaluate(ghostAI, walls, pacman, otherGhosts) {
          if (pacman.direction.x === 0 && pacman.direction.y === 0)
            return [null, 0.0];

          const predX =
            pacman.gridX + pacman.direction.x * this.predictionSteps;
          const predY =
            pacman.gridY + pacman.direction.y * this.predictionSteps;
          const predPos = {
            x: (predX + ghostAI.game.mapWidth) % ghostAI.game.mapWidth,
            y: (predY + ghostAI.game.mapHeight) % ghostAI.game.mapHeight,
          };

          if (walls.has(`${predPos.x},${predPos.y}`)) return [null, 0.0];

          const ghostPos = { x: ghostAI.ghost.gridX, y: ghostAI.ghost.gridY };
          const avoidPositions = new Set();
          otherGhosts.forEach((g) => {
            if (g !== ghostAI.ghost) {
              avoidPositions.add(`${g.gridX},${g.gridY}`);
            }
          });

          const direction = bfsNextStep(
            ghostPos,
            predPos,
            walls,
            ghostAI.game.mapWidth,
            ghostAI.game.mapHeight,
            avoidPositions
          );

          if (direction) {
            const distance = Math.sqrt(
              Math.pow(ghostPos.x - predPos.x, 2) +
                Math.pow(ghostPos.y - predPos.y, 2)
            );
            const strength = Math.min(1.0, 10.0 / (distance + 1));
            return [direction, strength * this.priority];
          }

          return [null, 0.0];
        }
      }

      class FlankPacmanRule extends GhostRule {
        constructor(priority = 2.0) {
          super(priority);
        }

        evaluate(ghostAI, walls, pacman, otherGhosts) {
          if (pacman.direction.x === 0 && pacman.direction.y === 0)
            return [null, 0.0];

          const predX = pacman.gridX + pacman.direction.x * 3;
          const predY = pacman.gridY + pacman.direction.y * 3;

          let flankPositions = [];
          if (pacman.direction.x !== 0) {
            flankPositions = [
              { x: predX, y: predY + 2 },
              { x: predX, y: predY - 2 },
            ];
          } else {
            flankPositions = [
              { x: predX + 2, y: predY },
              { x: predX - 2, y: predY },
            ];
          }

          const ghostPos = { x: ghostAI.ghost.gridX, y: ghostAI.ghost.gridY };
          const avoidPositions = new Set();
          otherGhosts.forEach((g) => {
            if (g !== ghostAI.ghost) {
              avoidPositions.add(`${g.gridX},${g.gridY}`);
            }
          });

          for (const targetPos of flankPositions) {
            const normPos = {
              x: (targetPos.x + ghostAI.game.mapWidth) % ghostAI.game.mapWidth,
              y:
                (targetPos.y + ghostAI.game.mapHeight) % ghostAI.game.mapHeight,
            };

            if (!walls.has(`${normPos.x},${normPos.y}`)) {
              const direction = bfsNextStep(
                ghostPos,
                normPos,
                walls,
                ghostAI.game.mapWidth,
                ghostAI.game.mapHeight,
                avoidPositions
              );
              if (direction) {
                const distance = Math.sqrt(
                  Math.pow(ghostPos.x - normPos.x, 2) +
                    Math.pow(ghostPos.y - normPos.y, 2)
                );
                const strength = Math.min(1.0, 5.0 / (distance + 0.1));
                return [direction, strength * this.priority];
              }
            }
          }

          return [null, 0.0];
        }
      }

      class AvoidOtherGhostsRule extends GhostRule {
        constructor(minDistance = 2, priority = 1.5) {
          super(priority);
          this.minDistance = minDistance;
        }

        evaluate(ghostAI, walls, pacman, otherGhosts) {
          const ghostPos = { x: ghostAI.ghost.gridX, y: ghostAI.ghost.gridY };

          const closeGhosts = otherGhosts.filter((ghost) => {
            if (ghost === ghostAI.ghost) return false;
            const distance = Math.sqrt(
              Math.pow(ghost.gridX - ghostPos.x, 2) +
                Math.pow(ghost.gridY - ghostPos.y, 2)
            );
            return distance < this.minDistance;
          });

          if (closeGhosts.length === 0) return [null, 0.0];

          const validDirs = [];
          for (const direction of DIRECTIONS) {
            const nextX =
              (ghostPos.x + direction.x + ghostAI.game.mapWidth) %
              ghostAI.game.mapWidth;
            const nextY =
              (ghostPos.y + direction.y + ghostAI.game.mapHeight) %
              ghostAI.game.mapHeight;

            if (!walls.has(`${nextX},${nextY}`)) {
              const totalDistance = closeGhosts.reduce((sum, closeGhost) => {
                const dist = Math.sqrt(
                  Math.pow(closeGhost.gridX - nextX, 2) +
                    Math.pow(closeGhost.gridY - nextY, 2)
                );
                return sum + dist;
              }, 0);

              validDirs.push({ direction, totalDistance });
            }
          }

          if (validDirs.length > 0) {
            const bestDirection = validDirs.reduce((best, current) =>
              current.totalDistance > best.totalDistance ? current : best
            ).direction;

            const minDistanceToGhost = Math.min(
              ...closeGhosts.map((g) =>
                Math.sqrt(
                  Math.pow(g.gridX - ghostPos.x, 2) +
                    Math.pow(g.gridY - ghostPos.y, 2)
                )
              )
            );
            const strength =
              (this.minDistance - minDistanceToGhost) / this.minDistance;

            return [bestDirection, strength * this.priority];
          }

          return [null, 0.0];
        }
      }

      class BlockEscapeRoute extends GhostRule {
        constructor(priority = 2.2) {
          super(priority);
        }

        evaluate(ghostAI, walls, pacman, otherGhosts) {
          const pacmanPos = { x: pacman.gridX, y: pacman.gridY };
          const exitPositions = [];

          for (const direction of DIRECTIONS) {
            const exitX =
              (pacman.gridX + direction.x + ghostAI.game.mapWidth) %
              ghostAI.game.mapWidth;
            const exitY =
              (pacman.gridY + direction.y + ghostAI.game.mapHeight) %
              ghostAI.game.mapHeight;
            if (!walls.has(`${exitX},${exitY}`)) {
              exitPositions.push({ x: exitX, y: exitY });
            }
          }

          if (exitPositions.length <= 1) return [null, 0.0];

          const blockedExits = new Set();
          otherGhosts.forEach((ghost) => {
            if (ghost !== ghostAI.ghost) {
              blockedExits.add(`${ghost.targetX},${ghost.targetY}`);
            }
          });

          let targetExit = null;
          for (const exitPos of exitPositions) {
            if (!blockedExits.has(`${exitPos.x},${exitPos.y}`)) {
              targetExit = exitPos;
              break;
            }
          }

          if (!targetExit) return [null, 0.0];

          const ghostPos = { x: ghostAI.ghost.gridX, y: ghostAI.ghost.gridY };
          const avoidPositions = new Set();
          otherGhosts.forEach((g) => {
            if (g !== ghostAI.ghost) {
              avoidPositions.add(`${g.gridX},${g.gridY}`);
            }
          });

          const direction = bfsNextStep(
            ghostPos,
            targetExit,
            walls,
            ghostAI.game.mapWidth,
            ghostAI.game.mapHeight,
            avoidPositions
          );

          if (direction) {
            const distance = Math.sqrt(
              Math.pow(ghostPos.x - targetExit.x, 2) +
                Math.pow(ghostPos.y - targetExit.y, 2)
            );
            const strength = Math.min(1.0, 5.0 / (distance + 0.1));
            return [direction, strength * this.priority];
          }

          return [null, 0.0];
        }
      }

      class WanderRule extends GhostRule {
        constructor(priority = 0.5) {
          super(priority);
        }

        evaluate(ghostAI, walls, pacman, otherGhosts) {
          const validDirs = [];
          const ghostPos = { x: ghostAI.ghost.gridX, y: ghostAI.ghost.gridY };

          for (const direction of DIRECTIONS) {
            const nextX =
              (ghostPos.x + direction.x + ghostAI.game.mapWidth) %
              ghostAI.game.mapWidth;
            const nextY =
              (ghostPos.y + direction.y + ghostAI.game.mapHeight) %
              ghostAI.game.mapHeight;

            if (!walls.has(`${nextX},${nextY}`)) {
              let collision = false;
              for (const ghost of otherGhosts) {
                if (
                  ghost !== ghostAI.ghost &&
                  ((ghost.gridX === nextX && ghost.gridY === nextY) ||
                    (ghost.targetX === nextX && ghost.targetY === nextY))
                ) {
                  collision = true;
                  break;
                }
              }
              if (!collision) {
                validDirs.push(direction);
              }
            }
          }

          if (validDirs.length === 0) return [null, 0.0];

          const chosenDirection =
            validDirs[Math.floor(Math.random() * validDirs.length)];
          return [chosenDirection, this.priority];
        }
      }

      // Rule-based AI
      class RuleBasedGhostAI {
        constructor(ghost, game, rules = []) {
          this.ghost = ghost;
          this.game = game;
          this.rules = rules;
        }

        getNextDirection(walls, pacman, otherGhosts) {
          const directionVotes = {};

          for (const rule of this.rules) {
            if (rule.enabled) {
              const [direction, strength] = rule.evaluate(
                this,
                walls,
                pacman,
                otherGhosts
              );
              if (direction && strength > 0) {
                const dirKey = `${direction.x},${direction.y}`;
                if (!directionVotes[dirKey]) {
                  directionVotes[dirKey] = { direction, totalStrength: 0 };
                }
                directionVotes[dirKey].totalStrength += strength;
              }
            }
          }

          if (Object.keys(directionVotes).length > 0) {
            const bestVote = Object.values(directionVotes).reduce(
              (best, current) =>
                current.totalStrength > best.totalStrength ? current : best
            );
            return bestVote.direction;
          }

          // Fallback to random movement
          const validDirs = this.getValidDirections(walls, otherGhosts);
          return validDirs.length > 0
            ? validDirs[Math.floor(Math.random() * validDirs.length)]
            : { x: 0, y: 0 };
        }

        getValidDirections(walls, otherGhosts) {
          const validDirections = [];
          const ghostPos = { x: this.ghost.gridX, y: this.ghost.gridY };

          for (const direction of DIRECTIONS) {
            const nextX =
              (ghostPos.x + direction.x + this.game.mapWidth) %
              this.game.mapWidth;
            const nextY =
              (ghostPos.y + direction.y + this.game.mapHeight) %
              this.game.mapHeight;

            if (!walls.has(`${nextX},${nextY}`)) {
              let collision = false;
              for (const ghost of otherGhosts) {
                if (
                  ghost !== this.ghost &&
                  ((ghost.gridX === nextX && ghost.gridY === nextY) ||
                    (ghost.targetX === nextX && ghost.targetY === nextY))
                ) {
                  collision = true;
                  break;
                }
              }
              if (!collision) {
                validDirections.push(direction);
              }
            }
          }

          return validDirections;
        }
      }

      // Difficulty Levels
      class DifficultyLevel {
        constructor(name, description, ruleSets) {
          this.name = name;
          this.description = description;
          this.ruleSets = ruleSets;
        }
      }

      class DifficultyManager {
        constructor() {
          this.currentLevel = 0;
          this.levels = this.createDifficultyLevels();
        }

        createDifficultyLevels() {
          return [
            new DifficultyLevel(
              "Beginner",
              "Short sight, no memory, simple patrol",
              [
                [
                  new EnhancedVisionRule(2, 1, 500, 2.0),
                  new IntelligentWanderRule(1.2),
                  new AvoidOtherGhostsRule(3, 1.0),
                ],
                [
                  new SmartPatrolRule(
                    [
                      { x: 5, y: 5 },
                      { x: 18, y: 5 },
                      { x: 18, y: 15 },
                      { x: 5, y: 15 },
                    ],
                    1.5
                  ),
                  new IntelligentWanderRule(1.0),
                  new AvoidOtherGhostsRule(3, 1.0),
                ],
                [
                  new IntelligentWanderRule(1.5),
                  new AvoidOtherGhostsRule(2, 0.8),
                ],
                [new WanderRule(1.0)],
              ]
            ),
            new DifficultyLevel(
              "Intermediate",
              "Medium sight, short memory, sound detection",
              [
                [
                  new EnhancedVisionRule(4, 2, 1500, 3.0),
                  new IntelligentWanderRule(1.0),
                  new AvoidOtherGhostsRule(2, 1.2),
                ],
                [
                  new SmartPatrolRule(
                    [
                      { x: 3, y: 3 },
                      { x: 20, y: 3 },
                      { x: 20, y: 16 },
                      { x: 3, y: 16 },
                    ],
                    2.0
                  ),
                  new EnhancedVisionRule(3, 2, 1000, 2.5),
                  new IntelligentWanderRule(1.0),
                  new AvoidOtherGhostsRule(2, 1.2),
                ],
                [
                  new EnhancedVisionRule(3, 1, 1000, 2.0),
                  new IntelligentWanderRule(1.2),
                  new AvoidOtherGhostsRule(2, 1.0),
                ],
                [
                  new IntelligentWanderRule(1.2),
                  new EnhancedVisionRule(2, 1, 500, 1.5),
                  new AvoidOtherGhostsRule(3, 0.8),
                ],
              ]
            ),
            new DifficultyLevel(
              "Advanced",
              "Good sight, memory, basic coordination, prediction",
              [
                [
                  new EnhancedVisionRule(6, 3, 3000, 3.5),
                  new PredictPacmanRule(2, 2.5),
                  new IntelligentWanderRule(1.0),
                  new AvoidOtherGhostsRule(1, 0.75),
                ],
                [
                  new EnhancedVisionRule(5, 2, 2500, 3.0),
                  new FlankPacmanRule(2.8),
                  new SmartPatrolRule(
                    [
                      { x: 2, y: 2 },
                      { x: 21, y: 2 },
                      { x: 21, y: 17 },
                      { x: 2, y: 17 },
                    ],
                    1.5
                  ),
                  new IntelligentWanderRule(1.0),
                  new AvoidOtherGhostsRule(1, 0.6),
                ],
                [
                  new EnhancedVisionRule(5, 2, 2000, 2.8),
                  new BlockEscapeRoute(2.5),
                  new IntelligentWanderRule(1.0),
                  new AvoidOtherGhostsRule(1, 0.5),
                ],
                [
                  new EnhancedVisionRule(4, 2, 2000, 2.5),
                  new PredictPacmanRule(1, 2.0),
                  new SmartPatrolRule(
                    [
                      { x: 12, y: 6 },
                      { x: 12, y: 12 },
                    ],
                    1.8
                  ),
                  new IntelligentWanderRule(1.0),
                ],
              ]
            ),
            new DifficultyLevel(
              "Expert",
              "Excellent sight, long memory, full coordination, advanced tactics",
              [
                [
                  new EnhancedVisionRule(8, 4, 5000, 4.0),
                  new PredictPacmanRule(3, 3.5),
                  new FlankPacmanRule(3.0),
                  new BlockEscapeRoute(2.5),
                  new IntelligentWanderRule(1.0),
                ],
                [
                  new EnhancedVisionRule(7, 5, 4500, 3.8),
                  new FlankPacmanRule(3.5),
                  new BlockEscapeRoute(3.2),
                  new PredictPacmanRule(2, 2.8),
                  new IntelligentWanderRule(1.0),
                ],
                [
                  new EnhancedVisionRule(7, 4, 4000, 3.5),
                  new BlockEscapeRoute(3.8),
                  new PredictPacmanRule(4, 3.0),
                  new FlankPacmanRule(2.5),
                  new IntelligentWanderRule(1.0),
                ],
                [
                  new EnhancedVisionRule(6, 3, 3500, 3.2),
                  new PredictPacmanRule(3, 3.0),
                  new FlankPacmanRule(2.8),
                  new BlockEscapeRoute(2.5),
                  new SmartPatrolRule(
                    [
                      { x: 12, y: 6 },
                      { x: 12, y: 12 },
                      { x: 6, y: 9 },
                      { x: 18, y: 9 },
                    ],
                    2.0
                  ),
                  new IntelligentWanderRule(1.0),
                ],
              ]
            ),
          ];
        }

        getCurrentLevel() {
          return this.levels[this.currentLevel];
        }

        nextLevel() {
          if (this.currentLevel < this.levels.length - 1) {
            this.currentLevel++;
            return true;
          }
          return false;
        }

        prevLevel() {
          if (this.currentLevel > 0) {
            this.currentLevel--;
            return true;
          }
          return false;
        }

        setLevel(levelIndex) {
          if (levelIndex >= 0 && levelIndex < this.levels.length) {
            this.currentLevel = levelIndex;
            return true;
          }
          return false;
        }

        createGhostAIs(ghosts, game) {
          const currentLevel = this.getCurrentLevel();
          const ghostAIs = [];

          for (let i = 0; i < ghosts.length; i++) {
            const ghost = ghosts[i];
            if (i < currentLevel.ruleSets.length) {
              const rules = currentLevel.ruleSets[i];
              const ghostAI = new RuleBasedGhostAI(ghost, game, rules);
              ghostAIs.push(ghostAI);
            } else {
              const basicRules = [new IntelligentWanderRule(1.0)];
              const ghostAI = new RuleBasedGhostAI(ghost, game, basicRules);
              ghostAIs.push(ghostAI);
            }
          }

          return ghostAIs;
        }

        getActiveRulesDescription() {
          const currentLevel = this.getCurrentLevel();
          const ruleNames = new Set();

          currentLevel.ruleSets.forEach((ruleSet) => {
            ruleSet.forEach((rule) => {
              ruleNames.add(rule.constructor.name);
            });
          });

          const ruleDescriptions = {
            EnhancedVisionRule: "Limited sight & memory",
            PredictPacmanRule: "Movement prediction",
            FlankPacmanRule: "Flanking maneuvers",
            AvoidOtherGhostsRule: "Ghost separation",
            SmartPatrolRule: "Adaptive patrol",
            BlockEscapeRoute: "Exit blocking",
            IntelligentWanderRule: "Smart exploration",
            WanderRule: "Random movement",
          };

          const descriptions = [];
          ruleNames.forEach((ruleName) => {
            if (ruleDescriptions[ruleName]) {
              descriptions.push(ruleDescriptions[ruleName]);
            }
          });

          return descriptions.join(", ");
        }
      }

      // Game entities
      class Pacman {
        constructor(x, y, game) {
          this.gridX = Math.floor(x / CELL_SIZE);
          this.gridY = Math.floor(y / CELL_SIZE);
          this.targetX = this.gridX;
          this.targetY = this.gridY;
          this.x = this.gridX * CELL_SIZE + CELL_SIZE / 2;
          this.y = this.gridY * CELL_SIZE + CELL_SIZE / 2;
          this.direction = { x: 0, y: 0 };
          this.nextDirection = { x: 0, y: 0 };
          this.moveProgress = 0.0;
          this.moveSpeed = PACMAN_SPEED;
          this.radius = CELL_SIZE / 2 - 2;
          this.mouthAngle = 0;
          this.mouthOpening = true;
          this.game = game;
        }

        setDirection(direction) {
          this.nextDirection = direction;
        }

        canMove(direction, walls) {
          let nextX = this.gridX + direction.x;
          let nextY = this.gridY + direction.y;

          nextX = (nextX + this.game.mapWidth) % this.game.mapWidth;
          nextY = (nextY + this.game.mapHeight) % this.game.mapHeight;

          return !walls.has(`${nextX},${nextY}`);
        }

        update(dt, walls) {
          if (this.gridX === this.targetX && this.gridY === this.targetY) {
            if (this.nextDirection.x !== 0 || this.nextDirection.y !== 0) {
              if (this.canMove(this.nextDirection, walls)) {
                this.direction = this.nextDirection;
                this.nextDirection = { x: 0, y: 0 };
              }
            }

            if (
              (this.direction.x !== 0 || this.direction.y !== 0) &&
              this.canMove(this.direction, walls)
            ) {
              this.targetX = this.gridX + this.direction.x;
              this.targetY = this.gridY + this.direction.y;

              this.targetX =
                (this.targetX + this.game.mapWidth) % this.game.mapWidth;
              this.targetY =
                (this.targetY + this.game.mapHeight) % this.game.mapHeight;

              this.moveProgress = 0.0;

              const isTunnelMove =
                Math.abs(this.targetX - this.gridX) > 1 ||
                Math.abs(this.targetY - this.gridY) > 1;

              if (isTunnelMove) {
                this.gridX = this.targetX;
                this.gridY = this.targetY;
                this.x = this.gridX * CELL_SIZE + CELL_SIZE / 2;
                this.y = this.gridY * CELL_SIZE + CELL_SIZE / 2;
                this.moveProgress = 0.0;
              }
            }
          }

          if (this.gridX !== this.targetX || this.gridY !== this.targetY) {
            this.moveProgress += dt * this.moveSpeed;

            if (this.moveProgress >= 1.0) {
              this.gridX = this.targetX;
              this.gridY = this.targetY;
              this.moveProgress = 0.0;
            } else {
              this.x =
                (this.gridX + (this.targetX - this.gridX) * this.moveProgress) *
                  CELL_SIZE +
                CELL_SIZE / 2;
              this.y =
                (this.gridY + (this.targetY - this.gridY) * this.moveProgress) *
                  CELL_SIZE +
                CELL_SIZE / 2;
            }
          }

          // Mouth animation
          if (this.direction.x !== 0 || this.direction.y !== 0) {
            if (this.mouthOpening) {
              this.mouthAngle += 300 * dt;
              if (this.mouthAngle >= 45) {
                this.mouthAngle = 45;
                this.mouthOpening = false;
              }
            } else {
              this.mouthAngle -= 300 * dt;
              if (this.mouthAngle <= 0) {
                this.mouthAngle = 0;
                this.mouthOpening = true;
              }
            }
          }
        }

        draw(ctx) {
          const center = { x: Math.floor(this.x), y: Math.floor(this.y) };

          ctx.fillStyle = YELLOW;
          ctx.beginPath();

          if (this.direction.x === 0 && this.direction.y === 0) {
            ctx.arc(center.x, center.y, this.radius, 0, 2 * Math.PI);
          } else {
            let angleOffset = 0;
            if (this.direction.x === 1) angleOffset = 0; // Right
            else if (this.direction.y === 1) angleOffset = Math.PI / 2; // Down
            else if (this.direction.x === -1) angleOffset = Math.PI; // Left
            else if (this.direction.y === -1) angleOffset = (3 * Math.PI) / 2; // Up

            const mouthRadians = (this.mouthAngle * Math.PI) / 180;
            const startAngle = angleOffset + mouthRadians;
            const endAngle = angleOffset - mouthRadians;

            ctx.arc(center.x, center.y, this.radius, startAngle, endAngle);
            ctx.lineTo(center.x, center.y);
          }

          ctx.fill();

          // Eye
          ctx.fillStyle = BLACK;
          let eyePos = { x: center.x, y: center.y - 5 };
          if (this.direction.x === 1)
            eyePos = { x: center.x - 3, y: center.y - 5 }; // Right
          else if (this.direction.x === -1)
            eyePos = { x: center.x + 3, y: center.y - 5 }; // Left
          else if (this.direction.y === 1)
            eyePos = { x: center.x + 5, y: center.y + 3 }; // Down
          else if (this.direction.y === -1)
            eyePos = { x: center.x - 5, y: center.y - 3 }; // Up

          ctx.beginPath();
          ctx.arc(eyePos.x, eyePos.y, 2, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      class Ghost {
        constructor(x, y, color, game) {
          this.gridX = Math.floor(x / CELL_SIZE);
          this.gridY = Math.floor(y / CELL_SIZE);
          this.targetX = this.gridX;
          this.targetY = this.gridY;
          this.x = this.gridX * CELL_SIZE + CELL_SIZE / 2;
          this.y = this.gridY * CELL_SIZE + CELL_SIZE / 2;
          this.color = color;
          this.direction =
            DIRECTIONS[Math.floor(Math.random() * DIRECTIONS.length)];
          this.moveProgress = 0.0;
          this.moveSpeed = GHOST_SPEED;
          this.size = CELL_SIZE - 4;
          this.animationTimer = 0;
          this.game = game;
          this.ai = null;
          this.decisionTimer = 0;
          this.decisionDelay = AI_DECISION_DELAY;
          this.lastDirection = { x: 0, y: 0 };
        }

        getColorName() {
          const colorNames = {
            [RED]: "Red",
            [BLUE]: "Blue",
            [PINK]: "Pink",
            [ORANGE]: "Orange",
          };
          return colorNames[this.color] || "Unknown";
        }

        setAI(ai) {
          this.ai = ai;
        }

        getValidDirections(walls, ghosts) {
          const validDirections = [];
          for (const direction of DIRECTIONS) {
            let nextX = this.gridX + direction.x;
            let nextY = this.gridY + direction.y;

            nextX = (nextX + this.game.mapWidth) % this.game.mapWidth;
            nextY = (nextY + this.game.mapHeight) % this.game.mapHeight;

            if (!walls.has(`${nextX},${nextY}`)) {
              validDirections.push(direction);
            }
          }
          return validDirections;
        }

        update(dt, walls, pacman, ghosts) {
          this.animationTimer += dt;
          this.decisionTimer += dt;

          if (this.gridX === this.targetX && this.gridY === this.targetY) {
            let newDirection = this.direction;

            if (this.ai && this.decisionTimer >= this.decisionDelay) {
              try {
                newDirection = this.ai.getNextDirection(walls, pacman, ghosts);
                this.decisionTimer = 0;
              } catch (e) {
                console.error("AI error:", e);
                const validDirs = this.getValidDirections(walls, ghosts);
                newDirection =
                  validDirs.length > 0 ? validDirs[0] : { x: 0, y: 0 };
              }
            }

            if (newDirection.x !== 0 || newDirection.y !== 0) {
              let nextX = this.gridX + newDirection.x;
              let nextY = this.gridY + newDirection.y;

              nextX = (nextX + this.game.mapWidth) % this.game.mapWidth;
              nextY = (nextY + this.game.mapHeight) % this.game.mapHeight;

              let canMove = !walls.has(`${nextX},${nextY}`);

              if (canMove) {
                for (const otherGhost of ghosts) {
                  if (otherGhost !== this) {
                    if (
                      (otherGhost.gridX === nextX &&
                        otherGhost.gridY === nextY) ||
                      (otherGhost.targetX === nextX &&
                        otherGhost.targetY === nextY)
                    ) {
                      canMove = false;
                      break;
                    }
                  }
                }
              }

              if (canMove) {
                this.direction = newDirection;
                this.targetX = nextX;
                this.targetY = nextY;
                this.moveProgress = 0.0;
                this.lastDirection = newDirection;
              } else {
                const fallbackDirs = this.getValidDirections(walls, ghosts);
                if (fallbackDirs.length > 0) {
                  const altDirection = fallbackDirs[0];
                  let altX = this.gridX + altDirection.x;
                  let altY = this.gridY + altDirection.y;

                  altX = (altX + this.game.mapWidth) % this.game.mapWidth;
                  altY = (altY + this.game.mapHeight) % this.game.mapHeight;

                  this.direction = altDirection;
                  this.targetX = altX;
                  this.targetY = altY;
                  this.moveProgress = 0.0;
                } else {
                  this.direction = { x: 0, y: 0 };
                }
              }
            }

            const isTunnelMove =
              Math.abs(this.targetX - this.gridX) > 1 ||
              Math.abs(this.targetY - this.gridY) > 1;

            if (isTunnelMove) {
              this.gridX = this.targetX;
              this.gridY = this.targetY;
              this.x = this.gridX * CELL_SIZE + CELL_SIZE / 2;
              this.y = this.gridY * CELL_SIZE + CELL_SIZE / 2;
              this.moveProgress = 0.0;
            } else {
              this.moveProgress = 0.0;
            }
          }

          if (this.gridX !== this.targetX || this.gridY !== this.targetY) {
            this.moveProgress += dt * this.moveSpeed;

            if (this.moveProgress >= 1.0) {
              this.gridX = this.targetX;
              this.gridY = this.targetY;
              this.moveProgress = 0.0;
              this.x = this.gridX * CELL_SIZE + CELL_SIZE / 2;
              this.y = this.gridY * CELL_SIZE + CELL_SIZE / 2;
            } else {
              this.x =
                (this.gridX + (this.targetX - this.gridX) * this.moveProgress) *
                  CELL_SIZE +
                CELL_SIZE / 2;
              this.y =
                (this.gridY + (this.targetY - this.gridY) * this.moveProgress) *
                  CELL_SIZE +
                CELL_SIZE / 2;
            }
          }
        }

        checkCollision(pacman) {
          const distance = Math.sqrt(
            Math.pow(this.x - pacman.x, 2) + Math.pow(this.y - pacman.y, 2)
          );
          return this.gridX === pacman.gridX && this.gridY === pacman.gridY;
        }

        draw(ctx) {
          const center = { x: Math.floor(this.x), y: Math.floor(this.y) };
          const halfSize = this.size / 2;

          // Body
          ctx.fillStyle = this.color;
          ctx.fillRect(
            center.x - halfSize,
            center.y - halfSize,
            this.size,
            this.size
          );

          // Head
          ctx.beginPath();
          ctx.arc(
            center.x,
            center.y - halfSize + halfSize / 2,
            halfSize,
            0,
            2 * Math.PI
          );
          ctx.fill();

          // Wavy bottom
          const bottomY = center.y + halfSize;
          const waveWidth = this.size / 4;

          for (let i = 0; i < 4; i++) {
            const x1 = center.x - halfSize + i * waveWidth;
            const x2 = x1 + waveWidth;
            const xMid = (x1 + x2) / 2;
            const waveOffset = 3 * Math.sin(this.animationTimer * 5 + i);

            ctx.beginPath();
            ctx.moveTo(x1, bottomY);
            ctx.lineTo(xMid, bottomY - waveWidth / 2 + waveOffset);
            ctx.lineTo(x2, bottomY);
            ctx.fill();
          }

          // Eyes
          const eyeSize = 3;
          const eyeY = center.y - halfSize / 2;

          ctx.fillStyle = WHITE;
          ctx.beginPath();
          ctx.arc(center.x - halfSize / 2, eyeY, eyeSize, 0, 2 * Math.PI);
          ctx.fill();

          ctx.beginPath();
          ctx.arc(center.x + halfSize / 2, eyeY, eyeSize, 0, 2 * Math.PI);
          ctx.fill();

          ctx.fillStyle = BLACK;
          ctx.beginPath();
          ctx.arc(center.x - halfSize / 2, eyeY, eyeSize / 2, 0, 2 * Math.PI);
          ctx.fill();

          ctx.beginPath();
          ctx.arc(center.x + halfSize / 2, eyeY, eyeSize / 2, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      // Map loader
      class MapLoader {
        loadMap(mapData) {
          const walls = new Set();
          const dots = new Set();
          const ghostStarts = [];
          let pacmanStart = null;

          for (let y = 0; y < mapData.length; y++) {
            const line = mapData[y];
            for (let x = 0; x < line.length; x++) {
              const char = line[x];
              if (char === "#") {
                walls.add(`${x},${y}`);
              } else if (char === ".") {
                dots.add(`${x},${y}`);
              } else if (char === "P") {
                pacmanStart = {
                  x: x * CELL_SIZE + CELL_SIZE / 2,
                  y: y * CELL_SIZE + CELL_SIZE / 2,
                };
              } else if (char === "G") {
                ghostStarts.push({
                  x: x * CELL_SIZE + CELL_SIZE / 2,
                  y: y * CELL_SIZE + CELL_SIZE / 2,
                });
              }
            }
          }

          if (!pacmanStart) {
            throw new Error("Pacman start position (P) not found in map!");
          }

          if (ghostStarts.length === 0) {
            throw new Error("Ghost start positions (G) not found in map!");
          }

          return {
            walls,
            dots,
            pacmanStart,
            ghostStarts,
          };
        }
      }

      // Main Game class
      class Game {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext("2d");
          this.mapWidth = 0;
          this.mapHeight = 0;

          this.difficultyManager = new DifficultyManager();
          this.ghostAIs = [];

          this.mapLoader = new MapLoader();
          this.loadMap(DEFAULT_MAP);

          this.state = GAME_PLAYING;

          this.setupEventListeners();
          this.lastTime = 0;
        }

        loadMap(mapData) {
          const mapInfo = this.mapLoader.loadMap(mapData);
          this.walls = mapInfo.walls;
          this.mapWidth =
            Math.max(
              ...Array.from(mapInfo.walls).map((pos) =>
                parseInt(pos.split(",")[0])
              )
            ) + 1;
          this.mapHeight =
            Math.max(
              ...Array.from(mapInfo.walls).map((pos) =>
                parseInt(pos.split(",")[1])
              )
            ) + 1;
          this.dots = new Set(mapInfo.dots);
          this.totalDots = this.dots.size;

          this.pacman = new Pacman(
            mapInfo.pacmanStart.x,
            mapInfo.pacmanStart.y,
            this
          );

          this.ghosts = [];
          const colors = [RED, BLUE, PINK, ORANGE];
          mapInfo.ghostStarts.forEach((ghostStart, i) => {
            const color = colors[i % colors.length];
            const ghost = new Ghost(ghostStart.x, ghostStart.y, color, this);
            this.ghosts.push(ghost);
          });

          this.setupGhostAI();
        }

        setupGhostAI() {
          this.ghostAIs = this.difficultyManager.createGhostAIs(
            this.ghosts,
            this
          );

          this.ghosts.forEach((ghost, i) => {
            if (i < this.ghostAIs.length) {
              ghost.setAI(this.ghostAIs[i]);
            }
          });
        }

        setupEventListeners() {
          document.addEventListener("keydown", (e) => this.handleKeyDown(e));
        }

        handleKeyDown(event) {
          if (this.state === GAME_PLAYING) {
            if (event.key === "Escape") {
              this.state = GAME_PAUSED;
            } else if (
              event.key === "ArrowUp" ||
              event.key === "w" ||
              event.key === "W"
            ) {
              this.pacman.setDirection(UP);
            } else if (
              event.key === "ArrowDown" ||
              event.key === "s" ||
              event.key === "S"
            ) {
              this.pacman.setDirection(DOWN);
            } else if (
              event.key === "ArrowLeft" ||
              event.key === "a" ||
              event.key === "A"
            ) {
              this.pacman.setDirection(LEFT);
            } else if (
              event.key === "ArrowRight" ||
              event.key === "d" ||
              event.key === "D"
            ) {
              this.pacman.setDirection(RIGHT);
            } else if (event.key === "+" || event.key === "=") {
              if (this.difficultyManager.nextLevel()) {
                this.setupGhostAI();
              }
            } else if (event.key === "-") {
              if (this.difficultyManager.prevLevel()) {
                this.setupGhostAI();
              }
            }
          } else if (this.state === GAME_PAUSED) {
            if (event.key === "Escape") {
              this.state = GAME_PLAYING;
            } else if (event.key === "r" || event.key === "R") {
              this.restartGame();
            } else if (event.key === "+" || event.key === "=") {
              if (this.difficultyManager.nextLevel()) {
                this.setupGhostAI();
              }
            } else if (event.key === "-") {
              if (this.difficultyManager.prevLevel()) {
                this.setupGhostAI();
              }
            } else if (event.key >= "1" && event.key <= "4") {
              const levelIndex = parseInt(event.key) - 1;
              if (this.difficultyManager.setLevel(levelIndex)) {
                this.setupGhostAI();
              }
            }
          } else if (this.state === GAME_WON || this.state === GAME_LOST) {
            if (event.key === "r" || event.key === "R") {
              this.restartGame();
            } else if (event.key === "Escape") {
              // Could add quit functionality here
            } else if (event.key === "+" || event.key === "=") {
              if (this.difficultyManager.nextLevel()) {
                this.setupGhostAI();
              }
            } else if (event.key === "-") {
              if (this.difficultyManager.prevLevel()) {
                this.setupGhostAI();
              }
            }
          }
        }

        restartGame() {
          this.loadMap(DEFAULT_MAP);
          this.state = GAME_PLAYING;
        }

        update(dt) {
          if (this.state !== GAME_PLAYING) return;

          this.dt = dt;

          this.pacman.update(dt, this.walls);

          // Check dot collection
          const pacmanGridPos = `${this.pacman.gridX},${this.pacman.gridY}`;
          if (this.dots.has(pacmanGridPos)) {
            this.dots.delete(pacmanGridPos);
          }

          if (this.dots.size === 0) {
            this.state = GAME_WON;
            return;
          }

          // Update ghosts
          for (const ghost of this.ghosts) {
            ghost.update(dt, this.walls, this.pacman, this.ghosts);
            if (ghost.checkCollision(this.pacman)) {
              this.state = GAME_LOST;
              return;
            }
          }
        }

        draw() {
          this.ctx.fillStyle = BLACK;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // Draw walls
          this.ctx.fillStyle = BLUE;
          for (const wallPos of this.walls) {
            const [x, y] = wallPos.split(",").map(Number);
            this.ctx.fillRect(
              x * CELL_SIZE,
              y * CELL_SIZE,
              CELL_SIZE,
              CELL_SIZE
            );
          }

          // Draw dots
          this.ctx.fillStyle = WHITE;
          for (const dotPos of this.dots) {
            const [x, y] = dotPos.split(",").map(Number);
            this.ctx.beginPath();
            this.ctx.arc(
              x * CELL_SIZE + CELL_SIZE / 2,
              y * CELL_SIZE + CELL_SIZE / 2,
              3,
              0,
              2 * Math.PI
            );
            this.ctx.fill();
          }

          // Draw pacman
          this.pacman.draw(this.ctx);

          // Draw ghosts
          for (const ghost of this.ghosts) {
            ghost.draw(this.ctx);
          }

          // Draw UI
          this.drawUI();

          if (this.state === GAME_PAUSED) {
            this.drawPauseScreen();
          } else if (this.state === GAME_WON) {
            this.drawWinScreen();
          } else if (this.state === GAME_LOST) {
            this.drawLoseScreen();
          }
        }

        drawUI() {
          // Only draw essential UI elements on the canvas that don't interfere with gameplay
          this.ctx.fillStyle = WHITE;
          this.ctx.font = "16px Arial";

          const eatenDots = this.totalDots - this.dots.size;
          this.ctx.fillText(`Score: ${eatenDots}/${this.totalDots}`, 10, 25);

          // Keep difficulty info minimal and at top right
          const currentLevel = this.difficultyManager.getCurrentLevel();
          this.ctx.textAlign = "right";
          this.ctx.font = "14px Arial";
          this.ctx.fillText(
            `${currentLevel.name} (${
              this.difficultyManager.currentLevel + 1
            }/4)`,
            this.canvas.width - 10,
            20
          );

          this.ctx.fillStyle = CYAN;
          this.ctx.font = "12px Arial";
          this.ctx.fillText("+/- difficulty", this.canvas.width - 10, 35);

          // Reset text alignment
          this.ctx.textAlign = "left";
        }

        drawPauseScreen() {
          // Semi-transparent overlay
          this.ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          this.ctx.fillStyle = WHITE;
          this.ctx.font = "48px Arial";
          this.ctx.textAlign = "center";
          this.ctx.fillText(
            "PAUSED",
            this.canvas.width / 2,
            this.canvas.height / 2 - 100
          );

          this.ctx.font = "24px Arial";
          this.ctx.fillText(
            "Press R to restart",
            this.canvas.width / 2,
            this.canvas.height / 2 - 30
          );

          this.ctx.fillStyle = YELLOW;
          this.ctx.font = "20px Arial";
          this.ctx.fillText(
            "DIFFICULTY LEVELS:",
            this.canvas.width / 2,
            this.canvas.height / 2 + 20
          );

          let yOffset = 50;
          this.difficultyManager.levels.forEach((level, i) => {
            const color =
              i === this.difficultyManager.currentLevel ? GREEN : WHITE;
            const prefix =
              i === this.difficultyManager.currentLevel ? "> " : "";

            this.ctx.fillStyle = color;
            this.ctx.font = "16px Arial";
            this.ctx.fillText(
              `${prefix}${i + 1}. ${level.name}`,
              this.canvas.width / 2,
              this.canvas.height / 2 + yOffset
            );
            yOffset += 25;

            if (i === this.difficultyManager.currentLevel) {
              this.ctx.fillStyle = CYAN;
              this.ctx.font = "12px Arial";
              this.ctx.fillText(
                level.description,
                this.canvas.width / 2,
                this.canvas.height / 2 + yOffset
              );
              yOffset += 20;
            }
          });

          this.ctx.fillStyle = CYAN;
          this.ctx.font = "14px Arial";
          this.ctx.fillText(
            "Use +/- or number keys (1-4) to change",
            this.canvas.width / 2,
            this.canvas.height / 2 + yOffset + 20
          );

          this.ctx.textAlign = "left";
        }

        drawWinScreen() {
          this.ctx.fillStyle = "rgba(0, 100, 0, 0.8)";
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          this.ctx.fillStyle = WHITE;
          this.ctx.font = "48px Arial";
          this.ctx.textAlign = "center";
          this.ctx.fillText(
            "YOU WIN!",
            this.canvas.width / 2,
            this.canvas.height / 2 - 50
          );

          this.ctx.font = "24px Arial";
          this.ctx.fillText(
            "All dots collected!",
            this.canvas.width / 2,
            this.canvas.height / 2
          );
          this.ctx.fillText(
            "Press R to restart",
            this.canvas.width / 2,
            this.canvas.height / 2 + 30
          );

          this.ctx.fillStyle = YELLOW;
          this.ctx.font = "16px Arial";
          this.ctx.fillText(
            "Use +/- to change difficulty",
            this.canvas.width / 2,
            this.canvas.height / 2 + 90
          );

          this.ctx.textAlign = "left";
        }

        drawLoseScreen() {
          this.ctx.fillStyle = "rgba(100, 0, 0, 0.8)";
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          this.ctx.fillStyle = WHITE;
          this.ctx.font = "48px Arial";
          this.ctx.textAlign = "center";
          this.ctx.fillText(
            "GAME OVER!",
            this.canvas.width / 2,
            this.canvas.height / 2 - 50
          );

          this.ctx.font = "24px Arial";
          this.ctx.fillText(
            "Ghost caught you!",
            this.canvas.width / 2,
            this.canvas.height / 2
          );
          this.ctx.fillText(
            "Press R to restart",
            this.canvas.width / 2,
            this.canvas.height / 2 + 30
          );

          this.ctx.fillStyle = YELLOW;
          this.ctx.font = "16px Arial";
          this.ctx.fillText(
            "Use +/- to change difficulty",
            this.canvas.width / 2,
            this.canvas.height / 2 + 90
          );

          this.ctx.textAlign = "left";
        }

        gameLoop(currentTime) {
          const dt = (currentTime - this.lastTime) / 1000.0;
          this.lastTime = currentTime;

          if (dt < 1.0) {
            // Prevent huge time jumps
            this.update(dt);
          }

          this.draw();

          requestAnimationFrame((time) => this.gameLoop(time));
        }

        updateInfo() {
          const gameInfoElement = document.getElementById("gameInfo");
          const currentLevel = this.difficultyManager.getCurrentLevel();
          const eatenDots = this.totalDots - this.dots.size;

          gameInfoElement.innerHTML = `
                    <strong>Score:</strong> ${eatenDots}/${
            this.totalDots
          } dots collected<br>
                    <strong>Difficulty:</strong> ${currentLevel.name} (Level ${
            this.difficultyManager.currentLevel + 1
          })<br>
                    <strong>Description:</strong> ${
                      currentLevel.description
                    }<br>
                    <strong>Active AI Rules:</strong> ${this.difficultyManager.getActiveRulesDescription()}
                `;

          // Debug info
          const debugElement = document.getElementById("debugInfo");
          const ghostInfo = this.ghosts
            .map((ghost, i) => {
              const ai = this.ghostAIs[i];
              const ruleNames = ai
                ? ai.rules.map((rule) => rule.constructor.name).join(", ")
                : "No AI";
              return `Ghost ${i + 1} (${ghost.getColorName()}): ${ruleNames}`;
            })
            .join("<br>");

          debugElement.innerHTML = `
                    <strong>Ghost AI Debug:</strong><br>
                    ${ghostInfo}<br>
                    <strong>Game State:</strong> ${this.state}<br>
                    <strong>Map Size:</strong> ${this.mapWidth}x${this.mapHeight}
                `;
        }
      }

      // Initialize and start the game
      let game;

      function initGame() {
        const canvas = document.getElementById("gameCanvas");
        game = new Game(canvas);

        // Start the game loop
        requestAnimationFrame((time) => {
          game.lastTime = time;
          game.gameLoop(time);
        });

        // Update info display regularly
        setInterval(() => {
          if (game) {
            game.updateInfo();
          }
        }, 100);
      }

      // Start the game when page loads
      window.addEventListener("load", initGame);
    </script>
  </body>
</html>
